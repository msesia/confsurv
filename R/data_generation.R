#' SurvivalDataGenerator: Synthetic Survival Data Generator
#'
#' This R6 class provides a flexible framework to generate synthetic survival datasets.
#' It combines a covariate generator, a survival time generator, and a censoring time generator to simulate realistic
#' time-to-event data with censoring.
#'
#' @section Fields:
#' \describe{
#'   \item{\code{covariate_generator}}{A function that takes \code{num_samples} as input and returns a covariate matrix or data frame.}
#'   \item{\code{survival}}{An object (e.g., subclass of \code{SurvivalDistribution}) with a \code{sample()} method for generating event times.}
#'   \item{\code{censoring}}{An object (e.g., subclass of \code{SurvivalDistribution}) with a \code{sample()} method for generating censoring times.}
#' }
#'
#' @section Methods:
#' \describe{
#'
#'   \item{\code{initialize(covariate_generator, survival_generator, censoring_generator)}}{
#'     Constructs a new \code{SurvivalDataGenerator} object.
#'     \itemize{
#'       \item \code{covariate_generator}: Function to sample covariates given sample size.
#'       \item \code{survival_generator}: A model object with \code{sample(X)} method for event times.
#'       \item \code{censoring_generator}: A model object with \code{sample(X)} method for censoring times.
#'     }
#'   }
#'
#'   \item{\code{sample(num_samples)}}{
#'     Generates a synthetic survival dataset with observed event/censoring times.
#'     \itemize{
#'       \item \code{num_samples}: Number of samples to generate.
#'     }
#'     Returns a \code{data.frame} with the following columns:
#'     \itemize{
#'       \item \code{event_time}: True (uncensored) event times.
#'       \item \code{censoring_time}: Sampled censoring times.
#'       \item \code{time}: Observed minimum of event and censoring time.
#'       \item \code{status}: Event indicator (1 = event observed, 0 = censored).
#'       \item \code{X1, X2, ..., Xp}: Covariates generated by the covariate generator.
#'     }
#'   }
#'
#' }
#'
#' @examples
#' # Simple constant-rate exponential generators
#' cov_gen <- function(n) { matrix(rnorm(n * 2), nrow = n) }
#' surv_gen <- ExponentialDistribution$new(rate_fun = function(X) rep(0.1, nrow(X)))
#' cens_gen <- ExponentialDistribution$new(rate_fun = function(X) rep(0.05, nrow(X)))
#'
#' generator <- SurvivalDataGenerator$new(cov_gen, surv_gen, cens_gen)
#' data <- generator$sample(100)
#'
#' head(data)
#'
#' @export
SurvivalDataGenerator <- R6::R6Class("SurvivalDataGenerator",
  public = list(
    covariate_generator = NULL,
    survival = NULL,
    censoring = NULL,

    initialize = function(covariate_generator, survival_generator, censoring_generator) {
      self$covariate_generator <- covariate_generator
      self$survival <- survival_generator
      self$censoring <- censoring_generator
    },

    sample = function(num_samples) {
      ## Generate covariates, true survival times, and censoring times
      X <- self$covariate_generator(num_samples)
      colnames(X) <- paste("X",1:ncol(X), sep="")
      T <- self$survival$sample(X)
      C <- self$censoring$sample(X)

      ## Determine observed time and event indicator
      time <- pmin(T, C)
      status <- as.integer(time == T)

      ## Create the final dataset
      data <- data.frame(event_time = T, censoring_time = C, time = time,
                         status = status, X)
      return(data)
    }

  )
)

#' LogNormalDistribution: Covariate-dependent Log-normal Survival Model
#'
#' This R6 class models survival times using a log-normal distribution, where the location
#' (mean on the log scale) and scale (standard deviation) parameters depend on input covariates.
#' It supports sampling, survival probability prediction, and quantile estimation.
#'
#' @format An R6 class generator object.
#'
#' @section Fields:
#' \describe{
#'   \item{\code{mu_fun}}{A user-supplied function that maps covariates \code{X} to the log-mean (\code{mu}) of the distribution.}
#'   \item{\code{sigma_fun}}{A user-supplied function that maps covariates \code{X} to the log-scale (\code{sigma}) of the distribution.}
#' }
#'
#' @section Methods:
#' \describe{
#'   \item{\code{initialize(mu_fun, sigma_fun)}}{
#'     Constructor. Takes functions defining how \code{mu} and \code{sigma} vary with covariates.
#'   }
#'
#'   \item{\code{sample(X, T = NULL, max_reps = 100)}}{
#'     Samples survival or censoring times for covariate matrix \code{X}.
#'     If \code{T} is provided, returns conditional samples satisfying \code{C > T[i]} using rejection sampling.
#'     \itemize{
#'       \item \code{X}: A data.frame or matrix of covariates.
#'       \item \code{T}: Optional vector of minimum allowed values (e.g., event times when modeling censoring).
#'       \item \code{max_reps}: Maximum number of resampling attempts per individual if \code{T} is provided.
#'     }
#'     Returns a numeric vector of sampled times.
#'   }
#'
#'   \item{\code{predict(X, time.points)}}{
#'     Computes survival probabilities \code{P(T > t)} for each row of \code{X} at each value in \code{time.points}.
#'     \itemize{
#'       \item \code{X}: Covariate matrix or data.frame.
#'       \item \code{time.points}: Vector of time values.
#'     }
#'     Returns a list with:
#'     \itemize{
#'       \item \code{predictions}: Matrix of survival probabilities (rows = individuals, cols = time points)
#'       \item \code{time.points}: The time grid used.
#'     }
#'   }
#'
#'   \item{\code{predict_quantiles(X, probs = c(0.25, 0.5, 0.75))}}{
#'     Computes survival time quantiles for specified survival probabilities.
#'     \itemize{
#'       \item \code{X}: Covariates.
#'       \item \code{probs}: Vector of survival probabilities (default: 25%, 50%, 75%).
#'     }
#'     Returns a data.frame where each row corresponds to an individual and columns are quantiles.
#'   }
#'
#'   \item{\code{fit(formula, data)}}{
#'     Placeholder (does nothing). Included for compatibility with other survival wrappers.
#'   }
#' }
#'
#' @examples
#' # Define covariate-dependent mu and sigma functions
#' mu_fn <- function(X) 0.5 * X[,1]
#' sigma_fn <- function(X) rep(0.5, nrow(X))
#'
#' # Create distribution object
#' dist <- LogNormalDistribution$new(mu_fun = mu_fn, sigma_fun = sigma_fn)
#'
#' # Sample from the distribution
#' X <- data.frame(X1 = rnorm(5), X2 = rnorm(5))
#' dist$sample(X)
#'
#' # Predict survival probabilities at fixed times
#' dist$predict(X, time.points = c(1, 2, 3))
#'
#' # Predict quantiles
#' dist$predict_quantiles(X, probs = c(0.25, 0.5, 0.75))
#'
#' @export
SurvivalDistribution <- R6::R6Class("SurvivalDistribution",
  public = list(
    ## Abstract methods
    ## Description: Initialize the survival distribution with necessary functions.
    ## Inputs: Should be defined by derived classes based on their specific needs.
    initialize = function(...) {
      stop("This method should be implemented by the derived class.")
    },

    ## Abstract method to sample survival times based on the distribution
    ## Inputs:
    ##   - X: A matrix of covariates
    ##   - T: (Optional) A vector of true survival times. If provided, times C are sampled conditional on C > T.
    ## Outputs:
    ##   - A numeric vector of survival times for each individual.
    sample = function(X, T=NULL) {
      stop("This method should be implemented by the derived class.")
    },

    ## Abstract method to predict survival probabilities at given time points
    ## Inputs:
    ##   - X: A matrix of covariates.
    ##   - time.points: A numeric vector of time points to predict survival probabilities.
    ## Outputs:
    ##   - A list containing:
    ##       - predictions: A matrix of survival probabilities for each individual at each time point.
    ##       - time.points: The time points used for predictions.
    predict = function(X, time.points) {
      stop("This method should be implemented by the derived class.")
    },

    ## Abstract method to predict quantiles of survival times
    ## Inputs:
    ##   - X: A matrix of covariates.
    ##   - probs: A numeric vector of probabilities for which to compute the quantiles (default c(0.25, 0.5, 0.75)).
    ## Outputs:
    ##   - A data frame where each row corresponds to an individual and each column corresponds to a quantile.
    predict_quantiles = function(X, probs = c(0.25, 0.5, 0.75)) {
      stop("This method should be implemented by the derived class.")
    }
  )
)

#' LogNormalDistribution: Parametric Log-Normal Survival Model
#'
#' This class implements a parametric survival distribution where survival times follow a log-normal distribution.
#' Both the log-mean (`mu`) and log-scale (`sigma`) can depend on covariates via user-defined functions.
#' This class is useful for simulating survival and censoring times or for benchmarking conformal methods.
#'
#' @section Inherits:
#' \code{\link{SurvivalDistribution}}: A base class interface for survival distributions.
#'
#' @section Fields:
#' \describe{
#'   \item{\code{mu_fun}}{A function taking covariate matrix \code{X} and returning a vector of log-means.}
#'   \item{\code{sigma_fun}}{A function taking covariate matrix \code{X} and returning a vector of log-standard deviations.}
#' }
#'
#' @section Methods:
#' \describe{
#'
#'   \item{\code{initialize(mu_fun, sigma_fun)}}{
#'     Constructor. Takes user-defined functions to parameterize the distribution.
#'     \itemize{
#'       \item \code{mu_fun}: A function of \code{X} returning log-mean values.
#'       \item \code{sigma_fun}: A function of \code{X} returning log-scale values.
#'     }
#'   }
#'
#'   \item{\code{sample(X, T = NULL, max_reps = 100)}}{
#'     Generates samples from the log-normal distribution for each row of \code{X}.
#'     If \code{T} is provided, sampling is conditional on the output being greater than \code{T[i]}.
#'     \itemize{
#'       \item \code{X}: Covariate matrix or data.frame.
#'       \item \code{T}: Optional vector of lower bounds (e.g. true event times, for censoring simulation).
#'       \item \code{max_reps}: Max number of rejection samples (default 100).
#'     }
#'     Returns a numeric vector of sampled times.
#'   }
#'
#'   \item{\code{predict(X, time.points)}}{
#'     Computes survival probabilities \code{P(T > t)} for given covariates and time grid.
#'     \itemize{
#'       \item \code{X}: Covariates.
#'       \item \code{time.points}: Vector of times.
#'     }
#'     Returns a list with:
#'     \itemize{
#'       \item \code{predictions}: A matrix of survival probabilities (rows = individuals, cols = times).
#'       \item \code{time.points}: The time grid used.
#'     }
#'   }
#'
#'   \item{\code{predict_quantiles(X, probs = c(0.25, 0.5, 0.75))}}{
#'     Computes time quantiles for each individual based on the log-normal parameters.
#'     \itemize{
#'       \item \code{X}: Covariates.
#'       \item \code{probs}: A numeric vector of survival quantiles (default = 25\%, 50\%, 75\%).
#'     }
#'     Returns a data.frame of quantiles per individual.
#'   }
#'
#'   \item{\code{fit(formula, data)}}{
#'     Placeholder for compatibility. Does nothing.
#'   }
#'
#' }
#'
#' @examples
#' # Define log-mean and log-scale as functions of covariates
#' mu_fun <- function(X) 0.5 * X[, 1]
#' sigma_fun <- function(X) rep(0.3, nrow(X))
#'
#' # Create a LogNormalDistribution object
#' dist <- LogNormalDistribution$new(mu_fun = mu_fun, sigma_fun = sigma_fun)
#'
#' # Simulate covariates and sample survival times
#' X <- data.frame(X1 = rnorm(5), X2 = rnorm(5))
#' sampled_times <- dist$sample(X)
#'
#' # Predict survival probabilities at times 1, 2, 3
#' dist$predict(X, c(1, 2, 3))
#'
#' # Predict survival quantiles (e.g., median)
#' dist$predict_quantiles(X, probs = c(0.5))
#'
#' @export
LogNormalDistribution <- R6::R6Class("LogNormalDistribution",
  inherit = SurvivalDistribution,
  public = list(
      mu_fun = NULL,                 ## Function to calculate mean based on covariates X
      sigma_fun = NULL,              ## Function to calculate standard deviation based on covariates X

    initialize = function(mu_fun, sigma_fun) {
        self$mu_fun <- mu_fun
        self$sigma_fun <- sigma_fun
    },

    sample = function(X, T=NULL, max_reps=100) {
        ## Ensure that we are working with a data frame excluding time and status if present
        if (is.data.frame(X)) {
            X <- X |> select(-any_of(c("time", "status")))
        }
        num_samples <- nrow(X)
        mu_x <- self$mu_fun(X)
        sigma_x <- self$sigma_fun(X)
        if(is.null(T)) {
            log_out <- rnorm(num_samples, mean = mu_x, sd = sigma_x)
            out <- exp(log_out)
        } else {
            ## Initialize output vector for conditional samples
            out <- rep(NA, num_samples)

            ## Loop through each individual and sample conditionally
            for (i in 1:num_samples) {
                iter <- 0
                while (iter < max_reps) {
                    log_C <- rnorm(1, mean = mu_x[i], sd = sigma_x[i])
                    C <- exp(log_C)

                    ## Check if the sampled value satisfies the condition C > T[i]
                    if (is.null(T) || C > T[i]) {
                        out[i] <- C
                        break  ## Exit the loop for this individual when C > T[i]
                    }
                    iter <- iter + 1
                }

                ## If maximum iterations exceeded, set the sample equal to T[i]
                if (is.na(out[i]) && !is.null(T)) {
                    out[i] <- T[i]
                    warning(paste("Max iterations exceeded for individual", i, "; sample set to T[i]."))
                }
            }
        }
        return(out)
    },

    predict = function(X, time.points) {
        ## Ensure that we are working with a data frame excluding time and status if present
        if (is.data.frame(X)) {
            X <- X |> select(-any_of(c("time", "status")))
        }

        ## Compute the mean (mu) and standard deviation (sigma) for each individual
        mu_x <- self$mu_fun(X)
        sigma_x <- self$sigma_fun(X)

        ## Initialize a matrix to store survival probabilities
        log_t <- log(time.points)
        log_t[time.points <= 0] <- -Inf  ## Handle non-positive time points

        ## Vectorized calculation of survival probabilities
        log_t_matrix <- matrix(log_t, nrow = nrow(X), ncol = length(time.points), byrow = TRUE)
        mu_matrix <- matrix(mu_x, nrow = nrow(X), ncol = length(time.points))
        sigma_matrix <- matrix(sigma_x, nrow = nrow(X), ncol = length(time.points))

        ## Compute the survival probabilities for all individuals at all time points
        z_scores <- (log_t_matrix - mu_matrix) / sigma_matrix
        predictions <- 1 - pnorm(z_scores)
        predictions[log_t_matrix == -Inf] <- 1  ## Survival probability is 1 at time 0 or negative times

        return(list(predictions = predictions, time.points = time.points))
    },

    predict_quantiles = function(X, probs = c(0.25, 0.5, 0.75)) {
        ## Ensure that we are working with a data frame excluding time and status if present
        if (is.data.frame(X)) {
            X <- X |> select(-any_of(c("time", "status")))
        }

        ## Compute the mean (mu) and standard deviation (sigma) for each individual
        mu_x <- self$mu_fun(X)
        sigma_x <- self$sigma_fun(X)

        ## Vectorized calculation of quantiles
        qnorm_matrix <- matrix(qnorm(probs), nrow = nrow(X), ncol = length(probs), byrow = TRUE)
        mu_matrix <- matrix(mu_x, nrow = nrow(X), ncol = length(probs))
        sigma_matrix <- matrix(sigma_x, nrow = nrow(X), ncol = length(probs))

        ## Calculate quantiles using the inverse survival function formula
        quantiles_matrix <- exp(mu_matrix + sigma_matrix * qnorm_matrix)

        ## Convert the quantiles matrix to a data frame
        quantiles_df <- as.data.frame(quantiles_matrix)
        colnames(quantiles_df) <- paste0("Q", probs * 100, "%")
        rownames(quantiles_df) <- paste0("Individual_", 1:nrow(quantiles_df))

        return(quantiles_df)
    },

    ## Abstract method that does not do anything. (For compatibility)
    fit = function(formula, data) {
    }

    )
  )

#' ExponentialDistribution: Parametric Exponential Survival Model
#'
#' This class defines a parametric survival model where times follow an exponential distribution.
#' The hazard rate (lambda) is modeled as a function of covariates through a user-provided function.
#' The class supports sampling, survival probability prediction, and quantile estimation.
#'
#' @section Inherits:
#' \code{\link{SurvivalDistribution}}: A generic base class for survival distributions.
#'
#' @section Fields:
#' \describe{
#'   \item{\code{rate_fun}}{Function that maps covariates to the exponential rate parameter (λ).}
#' }
#'
#' @section Methods:
#' \describe{
#'
#'   \item{\code{initialize(rate_fun)}}{
#'     Constructor that initializes the exponential distribution model.
#'     \itemize{
#'       \item \code{rate_fun}: A function of the covariate matrix \code{X} that returns a numeric vector of rates.
#'     }
#'   }
#'
#'   \item{\code{sample(X, T = NULL)}}{
#'     Draws samples from the exponential distribution using covariate-specific rates.
#'     If \code{T} is provided, the sampled values are conditionally shifted so that \code{C > T[i]} for each sample.
#'     \itemize{
#'       \item \code{X}: A matrix or data.frame of covariates.
#'       \item \code{T}: Optional vector of true survival times to enforce right-censoring.
#'     }
#'     Returns a numeric vector of sampled times.
#'   }
#'
#'   \item{\code{predict(X, time.points)}}{
#'     Computes survival probabilities \code{P(T > t)} for each individual at given time points.
#'     \itemize{
#'       \item \code{X}: Covariates.
#'       \item \code{time.points}: Numeric vector of time points.
#'     }
#'     Returns a list:
#'     \itemize{
#'       \item \code{predictions}: Matrix of survival probabilities (n_individuals × n_time_points).
#'       \item \code{time.points}: The vector of time points used.
#'     }
#'   }
#'
#'   \item{\code{predict_quantiles(X, probs = c(0.25, 0.5, 0.75))}}{
#'     Computes the survival quantiles (inverse CDF) for each individual.
#'     \itemize{
#'       \item \code{X}: Covariates.
#'       \item \code{probs}: Numeric vector of probabilities for quantile computation.
#'     }
#'     Returns a data.frame with quantile estimates per individual.
#'   }
#'
#'   \item{\code{fit(formula, data)}}{
#'     No-op method included for compatibility. Does not perform model fitting.
#'   }
#'
#' }
#'
#' @examples
#' # Define a rate function depending on the first covariate
#' rate_fun <- function(X) { exp(0.2 * X[, 1]) }
#'
#' # Instantiate the exponential distribution
#' exp_model <- ExponentialDistribution$new(rate_fun = rate_fun)
#'
#' # Generate some covariate data
#' X <- data.frame(X1 = rnorm(5), X2 = rnorm(5))
#'
#' # Sample times
#' sampled_times <- exp_model$sample(X)
#'
#' # Predict survival probabilities at t = 1, 2, 3
#' exp_model$predict(X, c(1, 2, 3))
#'
#' # Predict quantiles (e.g., median survival time)
#' exp_model$predict_quantiles(X, probs = 0.5)
#'
#' @export
ExponentialDistribution <- R6::R6Class("ExponentialDistribution",
  inherit = SurvivalDistribution,
  public = list(
      rate_fun = NULL,                 ## Function to calculate exponential rate based on covariates X

    initialize = function(rate_fun) {
        self$rate_fun <- rate_fun
    },

    sample = function(X, T = NULL) {
        ## Ensure that we are working with a data frame excluding time and status if present
        if (is.data.frame(X)) {
            X <- X |> select(-any_of(c("time", "status")))
        }
        num_samples <- nrow(X)
        ## Compute censoring rates
        censoring_rate <- self$rate_fun(X)

        ## Sample times from an exponential distribution
        out <- rexp(num_samples, rate = censoring_rate)

        ## If conditioning values T are provided, shift samples so that C > T
        if (!is.null(T)) {
            out <- out + T
        }

        return(out)
    },

    predict = function(X, time.points) {
        ## Ensure that X is a matrix (this should be the case for survival models)
        if (is.data.frame(X)) {
            X <- X |> select(-any_of(c("time", "status")))
        }

        ## Compute censoring rates using the rate function
        censoring_rate <- self$rate_fun(X)  ## Vector of length n_individuals

        ## Compute survival probabilities in a vectorized way
        ## pexp applied element-wise to time.points across censoring rates
        ## Expand censoring_rate to match the dimensions of time.points
        censoring_matrix <- matrix(censoring_rate, nrow = length(censoring_rate), ncol = length(time.points), byrow = FALSE)
        time_matrix <- matrix(time.points, nrow = length(censoring_rate), ncol = length(time.points), byrow = TRUE)

        predictions <- pexp(time_matrix, rate = censoring_matrix, lower.tail = FALSE)

        ## Return predictions and time points
        return(list(predictions = predictions, time.points = time.points))
    },


    predict_quantiles = function(X, probs = c(0.25, 0.5, 0.75)) {
        ## Ensure that X is a matrix (this should be the case for survival models)
        if (is.data.frame(X)) {
            X <- X |> select(-any_of(c("time", "status")))
        }

        ## Compute the censoring rates (λ) for each individual based on covariates
        censoring_rate <- self$rate_fun(X)  ## λ: a vector of length n_individuals

        ## Compute the exponential quantile function for each probability
        log_term <- -log(1 - probs)  ## Vectorized for probs: a vector of length n_probs

        ## Calculate quantiles for all individuals and all probabilities in a vectorized manner
        quantiles_matrix <- outer(1 / censoring_rate, log_term, "*")  ## n_individuals x n_probs matrix

        ## Convert the quantiles matrix to a data frame for easier handling
        quantiles_df <- as.data.frame(quantiles_matrix)

        ## Set appropriate column names for quantiles
        colnames(quantiles_df) <- paste0("Q", probs * 100, "%")

        ## Set appropriate row names for individuals
        rownames(quantiles_df) <- paste0("Individual_", 1:nrow(quantiles_df))

        return(quantiles_df)
    },


    ## Abstract method that does not do anything. (For compatibility)
    fit = function(formula, data) {
    }

    )
  )
